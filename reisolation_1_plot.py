
# modules
import polars as pl
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import warnings
import pandas as pd
from matplotlib.patches import Patch
from itertools import groupby
import warnings
import matplotlib.lines as mlines



# ~~~~~~~~~~~~~~~~~~~~~~~~~ PLOT REISOLATION ~~~~~~~~~~~~~~~~~~~~~~~~~ #
def add_line(ax, xpos, ypos, offset=1):
    line = plt.Line2D([xpos, xpos], 
                      [ypos + 1, ypos+(offset*0.01)],
                      transform=ax.transAxes, 
                      color='k', 
                      linewidth = 1)
    line.set_clip_on(False)
    ax.add_line(line)

def label_len(my_index,level):
    labels = my_index.get_level_values(level)
    return [(k, sum(1 for i in g)) for k,g in groupby(labels)]

def label_group_bar_table(ax, df, position="top"):
    offset = 1 if position == "top" else -1
    df = df.T
    ypos = 1 if position == "top" else 0
    scale = 1./df.index.size
    for level in range(df.index.nlevels)[::-1]:
        xpos = 0
        for label, rpos in label_len(df.index,level):
            if label == "col0":
                label = "$A. thaliana$ (Col-0)"
            if label == "gifu":
                label = "$L. japonicus$ (Gifu)"
            lxpos = (xpos + (.5) * rpos)*scale
            ax.text(lxpos, 
                    ypos + 0.5 if position == "top" else ypos+0.25, 
                    label, 
                    ha='center', 
                    transform=ax.transAxes)
            add_line(ax, xpos*scale, ypos, offset)
            xpos += rpos
        add_line(ax, xpos*scale , ypos, offset)
        ypos += offset




def plot_reisolation(predictions_df, 
                     figure_name="reisolation"):

    """
    generate a heatmap/barplot combination from the reisolated
    strains
    ----------
    reiso : pandas.DataFrame
        a pandas.DataFrame with the predicted reisolated strains
        generated by using predictReisolation
    Returns
    -------
    figure : matplotlib figure
        figure with some fancy visualization of the predicted
        reisolated population of bacteria
    """


    # reformat the data
    reiso = predictions_df.to_pandas()
    reiso = reiso.loc[reiso.plant != "medium",:]
    reiso.loc[reiso["strainID"] == "medium", "syncom"] = "medium"
    reiso["generation"] = reiso["generation"].astype(int)
    reiso = reiso.sort_values(by=['generation'])
    counts = reiso.groupby(["plant", "generation", "strainID", "syncom"])["strainID"].count().reset_index(name="count")
    gens = len(reiso["generation"].unique())
    countsWide = counts.pivot_table(values="count", columns=["plant", "generation"], index = ["syncom", "strainID"], dropna=False)
    countsWide = countsWide.loc[ ~countsWide.isna().all(axis=1),:]

    # get order after total counts
    order_df = (predictions_df
                .filter(pl.col("strainID") != "medium")
                .group_by("syncom", "strainID")
                .agg(pl.col("strainID").len().alias("counts")).sort("counts", descending=True)
                .sort("syncom") 
                .join(pl.read_csv("mapping/taxonomy.tsv", separator="\t").rename({"strain": "strainID"}), how="left", on="strainID")
                )

    strains = order_df["strainID"].to_list()
    family = order_df["family"].to_list()
    syncoms = order_df["syncom"].to_list()


    # reorder columns of heatmap dataframe
    ylim_df = (predictions_df
                .filter(pl.col("strainID") != "medium")
                .group_by("syncom", "strainID", "plant")
                .agg(pl.col("strainID").len().alias("counts")).sort("counts", descending=True)
                )
    maxVal = ylim_df["counts"].max() *1.1

    # plotting by syncom
    f, axes = plt.subplots(figsize=(10, 12), 
                           ncols=2,
                           nrows=len(strains) + 2,
                           gridspec_kw={'height_ratios': list(np.concatenate([[1] * len(strains), np.array([5]), np.array([1])])), 'width_ratios':[3,1]}
                          )
    
    # get info, whether its first of the lj-sphere
    first_lj = int(np.argwhere(np.array(syncoms) == "lj")[0][0])
    last_at = int(np.argwhere(np.array(syncoms) == "at")[-1][0])
    
    for syncom, strain, idx in zip(syncoms, strains, np.arange(len(strains))):
        print(f"idx, strain, syncom = {idx}, '{strain}', '{syncom}'")
        # 9: LjNodule218
        # 31: LjNodule218
        strainIdx = countsWide.index == (syncom, strain)
        strainCounts = countsWide.iloc[strainIdx,:].reset_index(level="syncom", drop=True)

        # color schemes
        if syncom == "lj":
            cmap = "Blues"
        elif syncom == "at":
            cmap = "Reds"
        elif syncom == "medium":
            cmap = "Greys"

        # heatmap stuff
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            ax = sns.heatmap(strainCounts, 
                             cmap = cmap, 
                             linewidths=0, 
                             ax = axes[idx, 0],
                             cbar=False,
                             annot=True,
                             annot_kws={"fontsize": 6},
                             fmt='g')
        if idx == 0:
            ax.xaxis.set_ticks_position("none")
            ax.xaxis.set_label_position("top")
            ax.spines['top'].set_visible(True)
            ax.set_xticklabels('')
            ax.set_xlabel('')
        else:
            ax.get_xaxis().set_visible(False)


        ax.set_ylabel("")
        ax.tick_params(axis='y', rotation=0)
        ax.vlines([gens], *ax.get_ylim(), color = "k")

        # add borders
        ax.spines['right'].set_visible(True)
        ax.spines['left'].set_visible(True)


        # secondary axis containing taxonomic family
        ax2 = ax.twinx()
        ax2.set_yticks([0.5])
        ax2.set_yticklabels([family[idx]], **dict(horizontalalignment = "center", x=1.15))

        # remove border
        ax2.spines['top'].set_visible(False)
        ax2.spines['right'].set_visible(False)
        ax2.spines['bottom'].set_visible(False)
        ax2.spines['left'].set_visible(False)

        # add stacked barplot with total reisolation
        perStrainTotal = pd.DataFrame(strainCounts.T.reset_index().groupby(["plant"])[strain].sum()).T
        perStrainTotal = perStrainTotal[["col0", "gifu"]]
        perStrainTotal.columns = ["Col-0", "Gifu"]
        strainPlot = perStrainTotal.plot.barh(stacked=False,
                                              grid=False,
                                              color={"Col-0": "red", "Gifu": "blue"},
                                              alpha = 0.6,
                                              width=1,
                                              ax=axes[idx, 1]
                                              )
        strainPlot.set_xlim(0, int(maxVal))
        strainPlot.xaxis.tick_top()
        strainPlot.set_yticklabels([""])

        # manage legend
        if idx == len(strains)-1:
            palette = {"$\it{A. thaliana}$ (Col-0)": "red", 
                       "$\it{L. japonicus}$ (Gifu)": "blue", }
            handles = [Patch(facecolor=palette[name], alpha=0.6) for name in palette]
            strainPlot.legend(handles, 
                              palette, 
                              title="Host plant", 
                              loc='upper center', 
                              bbox_to_anchor=(0.5, -.05),
                              frameon=False)
        else:
            strainPlot.legend_.remove()
        
        # set borders
        strainPlot.spines['top'].set_visible(False)
        strainPlot.spines['bottom'].set_visible(False)
        strainPlot.spines['right'].set_visible(True)
        strainPlot.spines['left'].set_visible(True)

        # remove ticks for all subplots except first one
        if idx != 0:
            strainPlot.set_xticks([])
        
        if (idx == 0):
            strainPlot.spines['top'].set_visible(True)
            strainPlot.set_xlabel("# of isolates per host plant")
            strainPlot.xaxis.set_label_position('top')
        
        # add a border between lj and at-sphere strains
        if idx == last_at:
            strainPlot.spines['bottom'].set_visible(True)
            ax.spines['bottom'].set_visible(True)
        if idx == first_lj:
            strainPlot.spines['top'].set_visible(True)
            ax.spines['top'].set_visible(True)

        if idx == len(strains)-1:
            strainPlot.spines['bottom'].set_visible(True)


    # # another pointplot at the bottom for comparison of at- and lj-sphere strains
    countsLong = countsWide.reset_index(level="syncom", drop=True).T.reset_index().melt(id_vars=["plant", "generation"])
    countsLong.loc[countsLong["strainID"].str.startswith("Lj"), "syncom"] = "lj"
    countsLong.loc[countsLong["strainID"].str.startswith("Root"), "syncom"] = "at"
    countsLong = countsLong.loc[~countsLong["syncom"].isna(),:]
    countsLong = countsLong.groupby(["plant", "generation", "syncom"]).sum("value").reset_index()
    countsLong["condition"] = countsLong["plant"] + ": " + countsLong["generation"].astype(str)
    countsLong = countsLong.sort_values(by=["plant", "generation", "syncom"])
    countsLong["sc_plant"] = countsLong["syncom"] + "_" + countsLong["plant"]

    # coloring
    countsLong.loc[countsLong["syncom"] == "at", "color"] = "red"
    countsLong.loc[countsLong["syncom"] == "lj", "color"] = "blue"
    palette = {condRow[1]["sc_plant"]: condRow[1]["color"] for condRow in countsLong.iterrows()}


    # plot total counts for reisolations
    loc=-2
    for syncom in countsLong["syncom"].unique():
        for plant in countsLong["plant"].unique():
            subset = countsLong.loc[(countsLong["syncom"] == syncom) & (countsLong["plant"] == plant)]
            axes[loc, 0].plot(subset["condition"], 
                              subset["value"],
                              color=subset["color"].unique()[0],
                              marker="o",
                             )
    # y axis label
    axes[loc, 0].set_ylim(0, countsLong["value"].max()*1.1)
    axes[loc, 0].set_ylabel("bacterial counts")
    axes[loc, 0].vlines([np.mean(axes[loc, 0].get_xticks())], *axes[loc, 0].get_ylim(), color = "k", linewidth = 1)
    
    # reformating of the plot
    axes[loc, 0].margins(x=0.03, y=0, tight=False)
    axes[loc, 0].set_ylabel("# of isolates\nper SynCom")
    axes[loc, 0].xaxis.set_ticks_position("none")
    axes[loc, 0].xaxis.set_label_position("bottom")
    axes[loc, 0].spines['bottom'].set_visible(True)
    axes[loc, 0].set_xticklabels('')
    axes[loc, 0].set_xlabel('')
    
    # add legend
    palette = {"$\it{At}$-SPHERE": "red", "$\it{Lj}$-SPHERE": "blue"}
    handles = [Patch(facecolor=palette[name]) for name in palette]
    handles = [mlines.Line2D([], [], 
                             color=palette[name], 
                             marker='o', 
                             linestyle='None',
                             markersize=6, 
                             label=name) for name in palette]
    axes[loc, 0].legend(handles, 
                        palette, 
                        title="SynCom", 
                        loc='center left', 
                        bbox_to_anchor=(1.01, 0.5),
                        frameon=False)

    # add the legend to the last plot
    loc = -1
    axes[loc, 0].xaxis.set_label_position("top")
    label_group_bar_table(axes[loc, 0], strainCounts.copy(), "bottom")
    axes[loc, 0].spines['bottom'].set_visible(False)
    axes[loc, 0].spines['left'].set_visible(False)
    axes[loc, 0].spines['right'].set_visible(False)
    axes[loc, 0].set_axis_off()

    # remove empty plots
    axes[-1, 1].remove()
    axes[-2, 1].remove()

    # general prettyness :)
    f.subplots_adjust(wspace=0.51, hspace=0)
    f.suptitle("Taxonomic distribution of recovered isolates (predicted)", 
               y=.95, 
               fontsize=18)

    # save figure to disk
    f.savefig(f"{figure_name}.pdf", transparent=True)
    f.savefig(f"{figure_name}.png", transparent=True)
    plt.clf()


plot_reisolation(pl.read_csv("raw_data/reisolation.tsv", separator="\t"), figure_name="figures/reisolation")
